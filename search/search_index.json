{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"linkml-datalog Validation and inference over LinkML instance data using Souffl\u00e9 schema data output Person : attributes : name : identifier : true friend_of : multivalued : true range : Person symmetric : true in_network_of : range : Person multivalued : true annotations : transitive_closure_of : friend_of persons : - name : p:akira friend_of : [ p : bill ] - name : p:bill friend_of : [ p : carrie ] - name : p:carrie friend_of : persons : - name : p:akira friend_of : - p:bill in_network_of : - p:akira - p:bill - p:carrie - name : p:bill friend_of : - p:carrie - p:akira in_network_of : - p:akira - p:bill - p:carrie - name : p:carrie friend_of : - p:bill in_network_of : - p:akira - p:bill - p:carrie Caveats This is currently experimental/alpha software!","title":"Introduction"},{"location":"#linkml-datalog","text":"Validation and inference over LinkML instance data using Souffl\u00e9 schema data output Person : attributes : name : identifier : true friend_of : multivalued : true range : Person symmetric : true in_network_of : range : Person multivalued : true annotations : transitive_closure_of : friend_of persons : - name : p:akira friend_of : [ p : bill ] - name : p:bill friend_of : [ p : carrie ] - name : p:carrie friend_of : persons : - name : p:akira friend_of : - p:bill in_network_of : - p:akira - p:bill - p:carrie - name : p:bill friend_of : - p:carrie - p:akira in_network_of : - p:akira - p:bill - p:carrie - name : p:carrie friend_of : - p:bill in_network_of : - p:akira - p:bill - p:carrie Caveats This is currently experimental/alpha software!","title":"linkml-datalog"},{"location":"basics/","text":"How it works Overview The linkml-dl wrapper works by executing the following steps: The schema is compiled to Souffle DL problem (see generated schema.dl file) Any embedded logic program in the schema is also added Data is converted to generic triple-like tuples (see *.facts ) Souffle is executed Inferred facts are collected: validation results are collected into a results object inferred facts are incorporated into new copy of the input object Compilation of schemas to Datalog Assuming input like this: classes : Person : class_uri : schema:Person attributes : age_in_years : range : integer maximum_value : 999 The generated souffle program will look like this: . decl Person ( i : symbol ) . decl Person_asserted ( i : identifier ) . output Person Person_asserted ( i ) :- triple ( i , RDF_TYPE , \"http://schema.org/Person\" ). Person ( i ) :- Person_asserted ( i ). . decl Person_age_in_years_asserted ( i : identifier , v : value ) . decl Person_age_in_years ( i : identifier , v : value ) . output Person_age_in_years . output Person_age_in_years_asserted Person_age_in_years ( i , v ) :- Person_age_in_years_asserted ( i , v ). Person_age_in_years_asserted ( i , v ) :- Person ( i ), triple ( i , \"https://w3id.org/linkml/examples/personinfo/age_in_years\" , v ). validation_result ( \"sh:MaxCountConstraintComponent\" , i , \"Person\" , \"age_in_years\" , v , \"Maximum is 999\" ) :- Person ( i ), Person_age_in_years ( i , v ), literal_number ( v , num ), num > 999. (note that most users never need to see these programs, but if you want to write advanced rules it is useful to understand the structure) Conversion of data to Facts The LinkML data file is converted to a triple-like model following the souffle spec: . decl triple ( s : symbol , p : symbol , o : symbol ) . decl literal_number ( s : symbol , o : number ) . decl literal_symbol ( s : symbol , o : symbol ) Under the hood, this is a two step process: convert the data to RDF using the standard rdflib dumper convert triple to the tuples above each triple is mapped to triple/3 facts if the object is a literal: it is serialized as a json string an additional fact is added mapping this to a souffle number or symbol Every slot-value assignment is turned into a triple. If the value is a literal/atom then an additional fact is added mapping the node to the number or symbol value. Execution linkml_datalog.engines.datalog_engine will do this compilation, translate your data to relational facts, then wrap calls to Souffle Note that Souffle needs to be on the command line for this to work Generated programs and facts will be placed in a temporary working directory, unless -d is passed. Parsing The engine will then read back all validation_result facts and translate these to the LinkML validation data model, and will walk the input object reading any new inferences","title":"Basics"},{"location":"basics/#how-it-works","text":"","title":"How it works"},{"location":"basics/#overview","text":"The linkml-dl wrapper works by executing the following steps: The schema is compiled to Souffle DL problem (see generated schema.dl file) Any embedded logic program in the schema is also added Data is converted to generic triple-like tuples (see *.facts ) Souffle is executed Inferred facts are collected: validation results are collected into a results object inferred facts are incorporated into new copy of the input object","title":"Overview"},{"location":"basics/#compilation-of-schemas-to-datalog","text":"Assuming input like this: classes : Person : class_uri : schema:Person attributes : age_in_years : range : integer maximum_value : 999 The generated souffle program will look like this: . decl Person ( i : symbol ) . decl Person_asserted ( i : identifier ) . output Person Person_asserted ( i ) :- triple ( i , RDF_TYPE , \"http://schema.org/Person\" ). Person ( i ) :- Person_asserted ( i ). . decl Person_age_in_years_asserted ( i : identifier , v : value ) . decl Person_age_in_years ( i : identifier , v : value ) . output Person_age_in_years . output Person_age_in_years_asserted Person_age_in_years ( i , v ) :- Person_age_in_years_asserted ( i , v ). Person_age_in_years_asserted ( i , v ) :- Person ( i ), triple ( i , \"https://w3id.org/linkml/examples/personinfo/age_in_years\" , v ). validation_result ( \"sh:MaxCountConstraintComponent\" , i , \"Person\" , \"age_in_years\" , v , \"Maximum is 999\" ) :- Person ( i ), Person_age_in_years ( i , v ), literal_number ( v , num ), num > 999. (note that most users never need to see these programs, but if you want to write advanced rules it is useful to understand the structure)","title":"Compilation of schemas to Datalog"},{"location":"basics/#conversion-of-data-to-facts","text":"The LinkML data file is converted to a triple-like model following the souffle spec: . decl triple ( s : symbol , p : symbol , o : symbol ) . decl literal_number ( s : symbol , o : number ) . decl literal_symbol ( s : symbol , o : symbol ) Under the hood, this is a two step process: convert the data to RDF using the standard rdflib dumper convert triple to the tuples above each triple is mapped to triple/3 facts if the object is a literal: it is serialized as a json string an additional fact is added mapping this to a souffle number or symbol Every slot-value assignment is turned into a triple. If the value is a literal/atom then an additional fact is added mapping the node to the number or symbol value.","title":"Conversion of data to Facts"},{"location":"basics/#execution","text":"linkml_datalog.engines.datalog_engine will do this compilation, translate your data to relational facts, then wrap calls to Souffle Note that Souffle needs to be on the command line for this to work Generated programs and facts will be placed in a temporary working directory, unless -d is passed.","title":"Execution"},{"location":"basics/#parsing","text":"The engine will then read back all validation_result facts and translate these to the LinkML validation data model, and will walk the input object reading any new inferences","title":"Parsing"},{"location":"install/","text":"Installation Install Souffl\u00e9 This project requires Souffl\u00e9 , a fast engine for executing datalog programs Install Souffle Make sure the souffle executable is on your command line: souffle --help Install LinkML-Datalog Python 3.9 is required. Install in the standard way from PyPi: pip install linkml-datalog Docker Docker containers will be provided in future","title":"Installation"},{"location":"install/#installation","text":"","title":"Installation"},{"location":"install/#install-souffle","text":"This project requires Souffl\u00e9 , a fast engine for executing datalog programs Install Souffle Make sure the souffle executable is on your command line: souffle --help","title":"Install Souffl\u00e9"},{"location":"install/#install-linkml-datalog","text":"Python 3.9 is required. Install in the standard way from PyPi: pip install linkml-datalog","title":"Install LinkML-Datalog"},{"location":"install/#docker","text":"Docker containers will be provided in future","title":"Docker"},{"location":"motivation/","text":"Motivation / Future Extensions Many of the previous examples shows functionality that could easily be achieved by other means: jsonschema shape languages: shex/shacl In fact the core linkml library already has wrappers for these. See working with data in linkml guide. However, jsonschema in particular offers very limited expressivity. There are many more opportunities for expressivity with linkml. In particular, LinkML 1.2 introduces autoclassification rules, conditional logic, and complex expressions -- THESE ARE NOT TRANSLATED YET , but they will be in future. For now there are three ways to get expressive logical rules in: Using existing metamodel logical slots Using dedicated annotations -- these may become bona fide metamodel slots in the future including rules in the header of your schema Use Cases Biolink TODO GFF3 There are many business rules that need encoded in a GFF schema: if the genome is non-circular then start<=end a codon is always of length 3 there exists some intron between two adjacent exons See more: Formalization of Genome Interval Relations Annotation QC Many annotation systems have QC rules TODO Templated ontology generation See linkml-owl When generating OWL ontologies from data we often want to perform inference over the input data, to check for consistency, and conformance to rules about structure. This is typically different from the axioms we use over the compiled OWL ontology.","title":"Motivation"},{"location":"motivation/#motivation-future-extensions","text":"Many of the previous examples shows functionality that could easily be achieved by other means: jsonschema shape languages: shex/shacl In fact the core linkml library already has wrappers for these. See working with data in linkml guide. However, jsonschema in particular offers very limited expressivity. There are many more opportunities for expressivity with linkml. In particular, LinkML 1.2 introduces autoclassification rules, conditional logic, and complex expressions -- THESE ARE NOT TRANSLATED YET , but they will be in future. For now there are three ways to get expressive logical rules in: Using existing metamodel logical slots Using dedicated annotations -- these may become bona fide metamodel slots in the future including rules in the header of your schema","title":"Motivation / Future Extensions"},{"location":"motivation/#use-cases","text":"","title":"Use Cases"},{"location":"motivation/#biolink","text":"TODO","title":"Biolink"},{"location":"motivation/#gff3","text":"There are many business rules that need encoded in a GFF schema: if the genome is non-circular then start<=end a codon is always of length 3 there exists some intron between two adjacent exons See more: Formalization of Genome Interval Relations","title":"GFF3"},{"location":"motivation/#annotation-qc","text":"Many annotation systems have QC rules TODO","title":"Annotation QC"},{"location":"motivation/#templated-ontology-generation","text":"See linkml-owl When generating OWL ontologies from data we often want to perform inference over the input data, to check for consistency, and conformance to rules about structure. This is typically different from the axioms we use over the compiled OWL ontology.","title":"Templated ontology generation"},{"location":"schema-rules/","text":"Schema level rules For now, you can also include your own rules in the header of your schema as an annotation E.g. see tests/inputs/personinfo.yaml, which has this as a schema-level annotation: id : https://w3id.org/linkml/examples/personinfo annotations : datalog : |- grandparent_of(i, j) :- parent_of(i, z), parent_of(z, j). grandfather_of(i, j) :- grandparent_of(i, j), is_man(i). grandmother_of(i, j) :- grandparent_of(i, j), is_woman(i). // GSSO-compliant definitions .decl is_man(i: identifier) .decl is_woman(i: identifier) is_man(i) :- gender(i, \"http://purl.obolibrary.org/obo/GSSO_000372\"). is_man(i) :- gender(i, \"http://purl.obolibrary.org/obo/GSSO_000371\"). is_woman(i) :- gender(i, \"http://purl.obolibrary.org/obo/GSSO_000384\"). is_woman(i) :- gender(i, \"http://purl.obolibrary.org/obo/GSSO_000385\"). See tests/ for more details.","title":"Schema Rules"},{"location":"schema-rules/#schema-level-rules","text":"For now, you can also include your own rules in the header of your schema as an annotation E.g. see tests/inputs/personinfo.yaml, which has this as a schema-level annotation: id : https://w3id.org/linkml/examples/personinfo annotations : datalog : |- grandparent_of(i, j) :- parent_of(i, z), parent_of(z, j). grandfather_of(i, j) :- grandparent_of(i, j), is_man(i). grandmother_of(i, j) :- grandparent_of(i, j), is_woman(i). // GSSO-compliant definitions .decl is_man(i: identifier) .decl is_woman(i: identifier) is_man(i) :- gender(i, \"http://purl.obolibrary.org/obo/GSSO_000372\"). is_man(i) :- gender(i, \"http://purl.obolibrary.org/obo/GSSO_000371\"). is_woman(i) :- gender(i, \"http://purl.obolibrary.org/obo/GSSO_000384\"). is_woman(i) :- gender(i, \"http://purl.obolibrary.org/obo/GSSO_000385\"). See tests/ for more details.","title":"Schema level rules"},{"location":"translations/","text":"Translations of LinkML to Datalog LinkML is primarily a data modeling language in the vein of JSON-Schema, UML, or a shape language like SHACL. The core is deliberately simple and does not have complex semantics. LinkML is also designed to be flexible, and there are extensions to the language that allow for more expressivity. Inheritance See: inheritance is_a and mixin slots are used in inference of categories. E.g. given: classes : Person : is_a : NamedThing the following datalog is exported: NamedThing ( i ) :- Person ( i ) This means someone querying data for instances of NamedThing would get instances of Person of course, a transitive hierarchy can be specified. Ranges See: ranges ranges are translated into validation checks. E.g. given: classes : Person : attributes : sibling_of : Person We get: validation_result ( 'sh:ClassConstraintComponent' , ...) :- Person ( i ), sibling_of ( i , j ), ! Person ( j ). Inverses Slots can be declared as inverses : sibling_of : inverse : sibling_of This will generate sibling_of(i,j) :- sibling_of(j,i). Transitive closures over LinkML 1.2 will introduce transitive_form_of , to declare that one slot (e.g. ancestor_of ) is the transitive form of another slot (e.g parent_of ) For now, you can get the same semantics from an annotation: ancestor_of : annotations : transitive_closure_of : parent_of This will generate ancestor_of(i,j) :- parent_of(j,i). ancestor_of(i,j) :- parent_of(j,z), ancestor_of(z,j). Association classes Compilation to datalog will also handle associative classes (e.g. reified statements). This is very useful when we want to be able to model associations such as familiar relationships or events such as marriage as first-class entities, but also have the convenience of a direct link: given: classes : Relationship : class_uri : rdf:Statement ## REIFICATION slots : - started_at_time - ended_at_time - related_to - type slot_usage : related_to : slot_uri : rdf:object type : slot_uri : rdf:predicate FamilialRelationship : is_a : Relationship slot_usage : type : range : FamilialRelationshipType required : true related to : range : Person required : true slots : sibling_of : inverse : sibling_of slot_uri : famrel:01 enums : FamilialRelationshipType : permissible_values : SIBLING_OF : meaning : famrel:01 PARENT_OF : meaning : famrel:02 CHILD_OF : meaning : famrel:03 this will assert a de-reified triple: triple ( i , p , v ) :- triple ( i , _ container_prop , r ), related_to ( r , v ), type ( r , p ). Such that if you have instance data id : P:002 has_familial_relationships : - related_to : P:001 type : SIBLING_OF There will be an inferred fact: sibling_of ( P : 002 , P : 001 ) Slot logical characteristics Additional characteristics can be specified as annotations annotations Supported: transitive reflexive transitive_closure_of Example: ancestor_of : annotations : transitive_closure_of : parent_of these will be added as bona-fide metamodel slots in LinkML 1.2. A special annotation is classified_from , this can be used to auto-classify using an enum based on another slot slots : age_category : range : AgeCategory annotations : classified_from : age_in_years enums : AgeCategory : permissible_values : adult : meaning : HsapDv:0000087 annotations : expr : v >= 19 infant : meaning : HsapDv:0000083 annotations : expr : v >= 0, v <= 2 adolescent : meaning : HsapDv:0000086 annotations : expr : v >= 13, v <= 18 This can be used to auto-assign enums based on numeric values for age. In LinkML 1.2 this will be done via classification rules. Other metamodel translations \"informative\" parts of the model intended for humans are not translated to datalog, as they have no logical entailments But there are other constructs coming in LinkML 1.2 slot relational characteristics: transitivity, symmetry, ... rich expression language conditional rules classification rules These will all have direct translations for datalog. For now it is necessary to manually encoded datalog rules for these.","title":"Translations"},{"location":"translations/#translations-of-linkml-to-datalog","text":"LinkML is primarily a data modeling language in the vein of JSON-Schema, UML, or a shape language like SHACL. The core is deliberately simple and does not have complex semantics. LinkML is also designed to be flexible, and there are extensions to the language that allow for more expressivity.","title":"Translations of LinkML to Datalog"},{"location":"translations/#inheritance","text":"See: inheritance is_a and mixin slots are used in inference of categories. E.g. given: classes : Person : is_a : NamedThing the following datalog is exported: NamedThing ( i ) :- Person ( i ) This means someone querying data for instances of NamedThing would get instances of Person of course, a transitive hierarchy can be specified.","title":"Inheritance"},{"location":"translations/#ranges","text":"See: ranges ranges are translated into validation checks. E.g. given: classes : Person : attributes : sibling_of : Person We get: validation_result ( 'sh:ClassConstraintComponent' , ...) :- Person ( i ), sibling_of ( i , j ), ! Person ( j ).","title":"Ranges"},{"location":"translations/#inverses","text":"Slots can be declared as inverses : sibling_of : inverse : sibling_of This will generate sibling_of(i,j) :- sibling_of(j,i).","title":"Inverses"},{"location":"translations/#transitive-closures-over","text":"LinkML 1.2 will introduce transitive_form_of , to declare that one slot (e.g. ancestor_of ) is the transitive form of another slot (e.g parent_of ) For now, you can get the same semantics from an annotation: ancestor_of : annotations : transitive_closure_of : parent_of This will generate ancestor_of(i,j) :- parent_of(j,i). ancestor_of(i,j) :- parent_of(j,z), ancestor_of(z,j).","title":"Transitive closures over"},{"location":"translations/#association-classes","text":"Compilation to datalog will also handle associative classes (e.g. reified statements). This is very useful when we want to be able to model associations such as familiar relationships or events such as marriage as first-class entities, but also have the convenience of a direct link: given: classes : Relationship : class_uri : rdf:Statement ## REIFICATION slots : - started_at_time - ended_at_time - related_to - type slot_usage : related_to : slot_uri : rdf:object type : slot_uri : rdf:predicate FamilialRelationship : is_a : Relationship slot_usage : type : range : FamilialRelationshipType required : true related to : range : Person required : true slots : sibling_of : inverse : sibling_of slot_uri : famrel:01 enums : FamilialRelationshipType : permissible_values : SIBLING_OF : meaning : famrel:01 PARENT_OF : meaning : famrel:02 CHILD_OF : meaning : famrel:03 this will assert a de-reified triple: triple ( i , p , v ) :- triple ( i , _ container_prop , r ), related_to ( r , v ), type ( r , p ). Such that if you have instance data id : P:002 has_familial_relationships : - related_to : P:001 type : SIBLING_OF There will be an inferred fact: sibling_of ( P : 002 , P : 001 )","title":"Association classes"},{"location":"translations/#slot-logical-characteristics","text":"Additional characteristics can be specified as annotations annotations Supported: transitive reflexive transitive_closure_of Example: ancestor_of : annotations : transitive_closure_of : parent_of these will be added as bona-fide metamodel slots in LinkML 1.2. A special annotation is classified_from , this can be used to auto-classify using an enum based on another slot slots : age_category : range : AgeCategory annotations : classified_from : age_in_years enums : AgeCategory : permissible_values : adult : meaning : HsapDv:0000087 annotations : expr : v >= 19 infant : meaning : HsapDv:0000083 annotations : expr : v >= 0, v <= 2 adolescent : meaning : HsapDv:0000086 annotations : expr : v >= 13, v <= 18 This can be used to auto-assign enums based on numeric values for age. In LinkML 1.2 this will be done via classification rules.","title":"Slot logical characteristics"},{"location":"translations/#other-metamodel-translations","text":"\"informative\" parts of the model intended for humans are not translated to datalog, as they have no logical entailments But there are other constructs coming in LinkML 1.2 slot relational characteristics: transitivity, symmetry, ... rich expression language conditional rules classification rules These will all have direct translations for datalog. For now it is necessary to manually encoded datalog rules for these.","title":"Other metamodel translations"},{"location":"usage/","text":"Usage Execution Minimally you need to specify two inputs: A linkml schema A datafi;e datafile in YAML, JSON, RDF, or TSV conformant with the schema Then run the linkml-dl script: linkml-dl -d tmp -s personinfo.yaml example_personinfo_data.yaml This produces two output: a ValidationReport object a new version of the data file, with new inferences injected on Inference Example The following schema models friend-of-a-friend networks. It introduces a class Person , with attributes: friend_of for stating one person is a friend of another in_network_of which is true if there is a chain of friendships between two people Schema foaf.yaml : id : http://example.org/foaf prefixes : ex : http://example.org/foaf/ p : http://example.org/person/ linkml : https://w3id.org/linkml/ default_prefix : ex imports : - linkml:types classes : Database : attributes : persons : range : Person multivalued : true inlined_as_list : true Person : attributes : name : identifier : true friend_of : multivalued : true range : Person symmetric : true in_network_of : range : Person multivalued : true annotations : transitive_closure_of : friend_of note that friend_of is declared transitive , and in_network_of has an annotation stating it is the transitive closure of friend_of Note in LinkML 1.2 there will be direct support for transitive_closure_of Don't worry about the Database class, this just acts as a holder for our main data objects, which is a list of Persons Data Data can be specified as YAML, JSON, or RDF. For simple flat schemas, data can also be passed as TSV/CSVs. foaf_data.{yaml,json,tsv,ttl} : YAML JSON TSV Turtle persons : - name : p:akira friend_of : [ p : bill ] - name : p:bill friend_of : [ p : carrie ] - name : p:carrie friend_of : { \"persons\" : [ { \"name\" : \"p:akira\" , \"friend_of\" : [ \"p:bill\" ] }, { \"name\" : \"p:bill\" , \"friend_of\" : [ \"p:carrie\" ] }, { \"name\" : \"p:carrie\" , \"friend_of\" : [] } ], } name friend_of p:akira p:bill p:bill p:carrie p:carrie @prefix ns1: <http://example.org/foaf/> . <http://example.org/person/akira> a ns1 : Person ; ns1 : friend_of <http://example.org/person/bill> . <http://example.org/person/bill> a ns1 : Person ; ns1 : friend_of <http://example.org/person/carrie> . <http://example.org/person/carrie> a ns1 : Person . [] a ns1 : Database ; ns1 : persons <http://example.org/person/akira> , <http://example.org/person/bill> , <http://example.org/person/carrie> . Execution Once you have a schema and a data file, you can run the script: linkml-dl -s foaf.yaml foaf_data.yaml This will generate an output file that is the input injected with inferred slot-values. persons : - name : p:akira friend_of : - p:bill in_network_of : - p:carrie - p:bill - p:akira - name : p:bill friend_of : - p:carrie - p:akira in_network_of : - p:carrie - p:bill - p:akira - name : p:carrie friend_of : - p:bill in_network_of : - p:carrie - p:bill - p:akira Validation Example For example, given a simple schema modeling Person objects, including an age slot with a specified range: Schema id : http://example.org/foaf prefixes : ex : http://example.org/foaf/ p : http://example.org/person/ linkml : https://w3id.org/linkml/ default_prefix : ex imports : - linkml:types default_curi_maps : - semweb_context classes : Database : attributes : persons : range : Person multivalued : true inlined_as_list : true Person : attributes : name : identifier : true age_in_years : range : integer minimum_value : 0 maximum_value : 200 Data foaf_data.{yaml,json,tsv,ttl} : YAML JSON TSV Turtle persons : - name : p:methuselah age_in_years : 999 { \"persons\" : [ { \"name\" : \"p:methuselah\" , \"age\" : 999 } ] } name age p:methuselah 999 @prefix ns1: <http://example.org/foaf/> . <http://example.org/person/methuselah> a ns1 : Person ; ns1 : age_in_years 999 . [] a ns1 : Database ; ns1 : persons <http://example.org/person/methuselah> . Execution You can execute in the same way. In this case we are not interested in new inferences, so we can suppress the writing of the inferred object file with --validate-only linkml-dl --validate-only -s foaf_validation.yaml foaf_validation_data.yaml This generates a validation report object conforming to the LinkML validation schema (modeled after SHACL): results : - type : sh:MaxInclusiveConstraintComponent subject : http://example.org/person/methuselah instantiates : Person predicate : age_in_years object_str : '999' info : Maximum is 200 A result of type sh:sh:MaxInclusiveConstraintComponent tells us that the subject (methuselah) has an age that exceeds the maximum specified in the schema == Note that this kind of simple validation can easily be done using frameworks like JSON-Schema, the advantage of LinkML datalog is the incoporation of expressive rules ==","title":"Usage"},{"location":"usage/#usage","text":"","title":"Usage"},{"location":"usage/#execution","text":"Minimally you need to specify two inputs: A linkml schema A datafi;e datafile in YAML, JSON, RDF, or TSV conformant with the schema Then run the linkml-dl script: linkml-dl -d tmp -s personinfo.yaml example_personinfo_data.yaml This produces two output: a ValidationReport object a new version of the data file, with new inferences injected on","title":"Execution"},{"location":"usage/#inference-example","text":"The following schema models friend-of-a-friend networks. It introduces a class Person , with attributes: friend_of for stating one person is a friend of another in_network_of which is true if there is a chain of friendships between two people","title":"Inference Example"},{"location":"usage/#schema","text":"foaf.yaml : id : http://example.org/foaf prefixes : ex : http://example.org/foaf/ p : http://example.org/person/ linkml : https://w3id.org/linkml/ default_prefix : ex imports : - linkml:types classes : Database : attributes : persons : range : Person multivalued : true inlined_as_list : true Person : attributes : name : identifier : true friend_of : multivalued : true range : Person symmetric : true in_network_of : range : Person multivalued : true annotations : transitive_closure_of : friend_of note that friend_of is declared transitive , and in_network_of has an annotation stating it is the transitive closure of friend_of Note in LinkML 1.2 there will be direct support for transitive_closure_of Don't worry about the Database class, this just acts as a holder for our main data objects, which is a list of Persons","title":"Schema"},{"location":"usage/#data","text":"Data can be specified as YAML, JSON, or RDF. For simple flat schemas, data can also be passed as TSV/CSVs. foaf_data.{yaml,json,tsv,ttl} : YAML JSON TSV Turtle persons : - name : p:akira friend_of : [ p : bill ] - name : p:bill friend_of : [ p : carrie ] - name : p:carrie friend_of : { \"persons\" : [ { \"name\" : \"p:akira\" , \"friend_of\" : [ \"p:bill\" ] }, { \"name\" : \"p:bill\" , \"friend_of\" : [ \"p:carrie\" ] }, { \"name\" : \"p:carrie\" , \"friend_of\" : [] } ], } name friend_of p:akira p:bill p:bill p:carrie p:carrie @prefix ns1: <http://example.org/foaf/> . <http://example.org/person/akira> a ns1 : Person ; ns1 : friend_of <http://example.org/person/bill> . <http://example.org/person/bill> a ns1 : Person ; ns1 : friend_of <http://example.org/person/carrie> . <http://example.org/person/carrie> a ns1 : Person . [] a ns1 : Database ; ns1 : persons <http://example.org/person/akira> , <http://example.org/person/bill> , <http://example.org/person/carrie> .","title":"Data"},{"location":"usage/#execution_1","text":"Once you have a schema and a data file, you can run the script: linkml-dl -s foaf.yaml foaf_data.yaml This will generate an output file that is the input injected with inferred slot-values. persons : - name : p:akira friend_of : - p:bill in_network_of : - p:carrie - p:bill - p:akira - name : p:bill friend_of : - p:carrie - p:akira in_network_of : - p:carrie - p:bill - p:akira - name : p:carrie friend_of : - p:bill in_network_of : - p:carrie - p:bill - p:akira","title":"Execution"},{"location":"usage/#validation-example","text":"For example, given a simple schema modeling Person objects, including an age slot with a specified range:","title":"Validation Example"},{"location":"usage/#schema_1","text":"id : http://example.org/foaf prefixes : ex : http://example.org/foaf/ p : http://example.org/person/ linkml : https://w3id.org/linkml/ default_prefix : ex imports : - linkml:types default_curi_maps : - semweb_context classes : Database : attributes : persons : range : Person multivalued : true inlined_as_list : true Person : attributes : name : identifier : true age_in_years : range : integer minimum_value : 0 maximum_value : 200","title":"Schema"},{"location":"usage/#data_1","text":"foaf_data.{yaml,json,tsv,ttl} : YAML JSON TSV Turtle persons : - name : p:methuselah age_in_years : 999 { \"persons\" : [ { \"name\" : \"p:methuselah\" , \"age\" : 999 } ] } name age p:methuselah 999 @prefix ns1: <http://example.org/foaf/> . <http://example.org/person/methuselah> a ns1 : Person ; ns1 : age_in_years 999 . [] a ns1 : Database ; ns1 : persons <http://example.org/person/methuselah> .","title":"Data"},{"location":"usage/#execution_2","text":"You can execute in the same way. In this case we are not interested in new inferences, so we can suppress the writing of the inferred object file with --validate-only linkml-dl --validate-only -s foaf_validation.yaml foaf_validation_data.yaml This generates a validation report object conforming to the LinkML validation schema (modeled after SHACL): results : - type : sh:MaxInclusiveConstraintComponent subject : http://example.org/person/methuselah instantiates : Person predicate : age_in_years object_str : '999' info : Maximum is 200 A result of type sh:sh:MaxInclusiveConstraintComponent tells us that the subject (methuselah) has an age that exceeds the maximum specified in the schema == Note that this kind of simple validation can easily be done using frameworks like JSON-Schema, the advantage of LinkML datalog is the incoporation of expressive rules ==","title":"Execution"}]}